#define X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE(r, data, elem) case data::elem : return BOOST_PP_STRINGIZE(elem);
#define ENUM(name, enumerators)  enum class name {BOOST_PP_SEQ_ENUM(enumerators)};namespace{inline std::string enum_to_string(name v){switch (v){BOOST_PP_SEQ_FOR_EACH(X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE,name,enumerators)default: return '[' + std::to_string((size_t)v) + " invalid " BOOST_PP_STRINGIZE(name) "]";}}}
#define ENUM_t(name,type, enumerators)enum class name : type {BOOST_PP_SEQ_ENUM(enumerators)};namespace{inline std::string enum_to_string(name v){switch (v){BOOST_PP_SEQ_FOR_EACH(X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE,name,enumerators)default: return '[' + std::to_string((type)v) + " invalid " BOOST_PP_STRINGIZE(name) "]";}}}
#define ENUM_ta(name,type, enumerators, aliases)enum class name : type {BOOST_PP_SEQ_ENUM(enumerators),BOOST_PP_SEQ_ENUM(aliases)};namespace{inline std::string enum_to_string(name v){switch (v){BOOST_PP_SEQ_FOR_EACH(X_DEFINE_ENUM_WITH_STRING_CONVERSIONS_TOSTRING_CASE,name,enumerators)default: return '[' + std::to_string((type)v) + " invalid " BOOST_PP_STRINGIZE(name) "]";}}}
#define AttachAManagedFun(name, min_args, content) ValueItem* name(ValueItem* args, uint32_t len) { if(len >= min_args){ do content while(false);\ }else CXX::arguments_range(len, min_args); return nullptr; }
#define AttachAFun(name, min_args, content) ValueItem* name(ValueItem* args, uint32_t len) { if(len >= min_args) return new ValueItem([&]() -> ValueItem{ do content while(false); return nullptr; }()); else CXX::arguments_range(len, min_args); return nullptr; }
